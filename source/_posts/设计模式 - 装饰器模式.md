---
title: "设计模式 - 装饰器模式"
catalog: true
date: 2020-08-28 11:20:24
subtitle: "Decorator"
header-img: "/img/default.png"
tags:
- 设计模式
catagories:
---

### 什么是装饰者模式？
装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。  
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。**装饰类和扩展类不会耦合，可以替代继承关系。**

### 优缺点
+ 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
+ 缺点：多层装饰比较复杂。

### Java代码实现
```java
// 公共接口
interface Car {
    void run();
}

// 第一个被包装类
class AutoMobile implements Car {
    public void run() {
        System.out.println("汽车跑起来了。。。");
    }
}

// 第二个被包装类
class ElectricCar implements Car {
    public void run() {
        System.out.println("电动车跑起来了。。。");
    }
}

// 装饰器类
class DecoratedCar implements Car {
    private Car car;

    public DecoratedCar(Car car) {
        this.car = car;
    }

    public void run() {
        System.out.println("开始给车打蜡。。。");
        System.out.println("开始给车加油。。。");
        car.run();
    }
}

// 测试类
public class Main {
    public static void main(String[] args) {
        Car eCar = new ElectricCar();
        Car aCar = new AutoMobile();

        DecoratedCar decoratedElectricCar = new DecoratedCar(eCar);
        DecoratedCar decoratedAutoMobile = new DecoratedCar(aCar);

        decoratedElectricCar.run();
        System.out.println("------------divide--------------");
        decoratedAutoMobile.run();
    }
}
```

输出结果
```shell
开始给车打蜡。。。
开始给车加油。。。
电动车跑起来了。。。
------------divide--------------
开始给车打蜡。。。
开始给车加油。。。
汽车跑起来了。。。
```
看到这，我相信你一定发现这个设计模式和代理模式非常相似，不同点在于代理模式中的被代理类是在代理类内部new出来。而装饰器模式中被装饰的实例是在客户端new出来，再装饰器的构造函数注入进去，因此还是有一些区别的。**代理模式的被代理类对于客户端来说是不可知的，而装饰器模式的被装饰类是客户端指定的。**

