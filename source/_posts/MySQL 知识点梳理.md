---
title: "MySQL 知识点梳理"
catalog: true
date: 2020-08-01 16:51:24
subtitle: ""
header-img: "/img/default.png"
tags:
- 后端
- Mysql
catagories:
---

终于得空梳理一下MySQL的知识点了，过去三年里由于业务场景特殊的原因，关系型数据库很少用到，渐渐的很多知识都开始淡忘了，今天就好好整理一下。
MySQL是目前全世界最受欢迎的开源数据库，免费，高性能，可扩展是MySQL的三大标签，可以说MySQL是学习数据库最好的起点。
和MySQL类似的，市面上主流的数据库还有Oracle和PostgreSQL这两款。Oracle功能强大，但也以价格贵而出名。Postgre也叫PGSQL，和Oracle类似，支持类型丰富，能很好胜任高并发的应用场景，相比MySQL更加稳定，因此更适合金融等严苛的企业应用场景，而MySQL更适合业务逻辑相对简单数据可靠性要求低一些的互联网场景。

### 数据库基础知识

#### 关系型数据库

关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。

#### SQL

关系型数据库采用结构化查询语言（即SQL）来对数据库进行查询，SQL早已获得了各个数据库厂商的支持，成为数据库行业的标准，它能够支持数据库的CRUD（增加，查询，更新，删除）操作，具有非常强大的功能，SQL可以采用类似索引的方法来加快查询操作。SQL由可细分为：
+ DDL：数据库设计语言
+ DML：数据库操作语言
+ DCL：数据库控制语言
+ DQL：数据库查询语言

#### 数据库设计三大范式

+ 第一范式(确保每列保持原子性)  
第一范式是最基本的范式。如果数据库表中的所有字段值都是`不可分解的原子值`，就说明该数据库表满足了第一范式。
第一范式的合理遵循需要根据系统的`实际需求`来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式。

+ 第二范式(确保表中的每列都和主键相关)
第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

+ 第三范式(确保每列都和主键列直接相关,而不是间接相关)
第三范式在第二范式上更进一层，比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。

#### 事务4大特性(ACID)

+ **原子性(Atomicity)**
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

+ **一致性（Consistency）**
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

+ **隔离性（Isolation）**
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

+ **持久性（Durability）**
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

#### 事务隔离4个等级

| 等级 | 脏读 | 不可重复读 | 幻读 |
| -- | -- | -- | -- |
| 读未提交(RU) | 有 | 有 | 有 |
| 读已提交(RC) | 无 | 有 | 有 |
| 重复读(RR) | 无 | 无 | 有 |
| 串行(Serializable) | 无 | 无 | 无 |

+ **读未提交**
由于读时未对数据行加锁，导致事务A可能读取到B未提交的数据，当事务B回滚时，A读到的数据即为脏数据。一般不建议使用此等级。
+ **读已提交**
在读数据时加行级共享锁，读完该行数据后释放。修改时加行级排他锁。事务A读数据时对当前行加了共享锁，导致事务B想要修改数据时无法获取排他锁资源而被阻塞，避免了脏读的发生。但是由于是读完数据立即释放共享锁，因此事务A如果多次读取数据时，有可能出现数据不一致情况，这种问题称为不可重复读。
+ **可重复读**
在读数据时加行级共享锁，事务完成后再释放。修改时加行级排他锁，也是事务完成后才释放。这样事务A读数据时，无论读多少次，B始终无法获取到排他锁资源。无法进行数据修改，因此读到的结果始终一致。可重复读只能防止数据更新。但是当有新的数据插入时，还是可能会导致数据查询结果不一致。
+ **序列化**
Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

#### 共享锁和排他锁

在MySQL中有行级锁，页级锁，表级锁。行级锁是MySQL中最系力度的锁。行级锁又分为共享锁和排他锁两种。  
+ **共享锁**
共享锁又称为读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有的共享锁。
+ **排他锁**
排他锁又称写锁，如果事务T对数据A加上排他锁，则其他事务不能再对A加任何类型的锁。得到锁的事务既可以读又可以写。

#### 悲观锁和乐观锁

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
乐观锁CAS：InnoDB隐式地维护了两个版本好，创建版本和删除版本。每次提交事务会和这两个版本进行比对。虽然增加了表空间大小，但是减少了锁的使用，极大提高了性能。

### MySQL知识

#### MySQL存储引擎

+ **InnoDB存储引擎**
InnoDB是事务性数据库的首选引擎，支持事务安全表（ACID），支持锁定和外键。由于支持事务，能够实现行粒度锁，在提高业务安全性的同时保证了较的高性能。
InnoDB的数据和索引是放在同一个逻辑表空间下的，文件大小上限64TB。InnoDB表支持外键约束，存储数据时按照主键顺序存放，没有指定主键时，InnoDB会为每一行生成6个字节的ROWID并作为主键。
+ **MyISAM**
MyISAM是基于ISAM存储引擎，并对其进行扩展。它是在Web，数据仓储和其他环境下最常用的存储引擎之一。MyISAM拥有较高的插入，查询速度，但不支持事务。
+ **MEMORY存储引擎**
MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。

#### MySQL索引类型

+ 主键索引 PRIMARY KEY
+ 唯一索引 UNIQUE INDEX
+ 普通索引 INDEX index_name('column_name')
+ 组合索引 INDEX index_name('col1', 'col2', 'col3')
+ 全文索引 FULLTEXT

#### 索引的优缺点

索引就像字典的目录一样，可以帮我们快速定位到我们需要查阅的数据，如果没有索引，数据库在查找时就不得不全表扫描。要知道数据库中的数据是存储在磁盘上，而不是内存中。全表扫描会带来巨大的I/O开销，当数据量巨大时，查询时间会无法控制。

**优势**
可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；索引是行级锁的前提，没有索引，行级锁无法使用。

**劣势**
索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；

#### 索引的数据结构及原理

这里记录一篇美团技术团队整理的文章，介绍的非常详细。[MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

#### 如何优化MySQL性能

1. 尽量避免全表扫描查询，合理简历索引。
2. 索引应选择辨识高的列，如果建立了组合索引，应遵循左前缀原则设立。
3. 即便有索引，也要避免`LIKE ‘%XX’` 通配符开头的模糊查询，会使索引失效。
4. 避免SELECT * 查询，只返回选择所需的列，减少I/O开销。
5. 避免多个范围查询条件，会使索引失效。
6. 覆盖索引，上面美团博客那篇文章中的案例特别棒。可以用于优化分页查询。
7. 尽量不要用数据库进行数据运算，会拉高CPU占用。
8. 并发要求极高时，可以使用读写分离架构，部署只读实例，提高性能。






