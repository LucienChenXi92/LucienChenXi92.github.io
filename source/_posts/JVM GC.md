---
title: "JVM GC"
catalog: true
date: 2020-03-22 22:51:24
subtitle: ""
header-img: "/img/default.png"
tags:
- 后端
- Java
catagories:
---

### Heap内存分区
+ 新生代 1/3
    + 伊甸区(Eden) 内存占比8/10
        + 生还者0区(Survivor 0) 内存占比1/10
        + 生还者1区(Survivor 1) 内存占比1/10
+ 老年代 2/3
+ 永久代: JDK 1.7之前hotspot有永久代的概念，用以实现方法区的功能，在Java 1.8后移除了永久代的概念。方法区被移至元空间(Metaspace)

### GC 回收标记算法

+ 引用计数器
每个对象都有一个计数器，没被引用一次便+1，失去引用便-1，当引用次数为0时并持续一段时间后，可以被回收。但是此算法无法解决两个对象相互引用的情况。
+ 可达性分析法
从Root node 开始不断寻找引用对象，构成一条或多条引用链。如果有对象不在引用链中，则此对象可以被回收。此方法可以解决相互引用的情况。

### GC 算法
+ 标记-清除(MS)
    + 根据可达性分析，找到无引用的对象进行标记，标记完成后进行删除
    + 优点: 对内存空间无要求，效率相对标记-整理较高
    + 不足: 清除后会产生内存空间碎片，内存可利率变低，从而加速GC的频率
+ 拷贝-清除(CS)
    + 将整块内存分成两等分，每次只使用其中的一块。GC时，根据可达性分析，将需要保留的对象复制到另一块盘上，然后将原内存盘清空。
    + 优点: 当需保留的对象很少时效率很高，GC后内存平整，无空间碎片。
    + 不足: 每次只使用所有内存的一半，内存使用率低
+ 标记-整理(MC)
    + 其过程和标记-清除算法类似，只不过在标记后没有直接进行清理，而是将所有对象进行排序，将需要保留的对象排到内存的一端，然后再将需要清除的对象一次性清理掉。
    + 优点: 空间利用率高，无空间碎片产生
    + 不足: 效率相对标记-清除的效率效率低

### 分代收集策略
对Heap内存进行区域划分，充分利用各种算法的优点进行分代收集，把Java Heap分为新生代和老年代，根据不同代的特点选用不同的GC算法。

+ 新生代
采用灵活比例的复制算法，每当伊甸区内存满了即会触发Minor GC(Young GC)，基于IBM的调查结果，新生代中98%的对象都会被首次GC清除掉，因此剩余的对象会被刷入Survivor 0区，下次GC时，会将Survivor 0区和Eden区的剩余对象一同刷入Survivor 1区。GC多次仍然无法清除掉的对象最终被刷入老年代。
+ 老年代
由于老年代中的对象存活率高，没有额外的空间进行分配，必须使用标记-清除或标记整理算法。

### 垃圾收集器
1. 串行：垃圾回收器(Serial Garbage Collector)
    + 串行垃圾回收器是最古老的，在GC时它会冻结所有程序线程，使用单个垃圾回收线程进行垃圾回收。此垃圾回收器是为单线程环境设计的。
    + GC时会产生较长的的Stop The World(服务暂停)
    + 使用方法：-XX:+UseSerialGC 串联收集
2. 串行：ParNew收集器
    + ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行。新生代复制算法，老年代标记压缩
    + 使用方法：-XX:+UseParNewGC ParNew收集器
3. 并行： Parallel收集器
    + Parallel Scavenge收集器类似ParNew收集器，Parallel收集器关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机根据当前系统的运行状况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或是多大比例；新生代复制算法，老年代标记-整理
4. 并行： Parallel Old收集器
    + Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记整理算法”。JDK 1.6才开始提供使用
5. 并发标记扫描 CMS收集器
    + CMS(Concurrent Mark Sweep)收集器是一种获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网网站或B/S系统的服务上，这类应用尤其重视服务的相应速度，希望系统停顿的时间最短，以给用户带来较好的体验。
    + CMS是基于标记-清除算法实现的，它的运作过程相对前面集中收集器来说更为复杂一些，整个过程分为4个过程
        + 初始标记
            + Stop The World
            + 标记GC Roots能够直接关联到的对象，速度很快
        + 并发标记
            + 执行时间较长，工作线程不停顿
            + 基于初始标记的结果，多线程GC Roots Tracing，在这个过程中由于工作线程还在不断产生新的需要收集的对象，因此还需要下一步重新标记
        + 重新标记
            + Stop The World
            + 修正并发期间因用户程序继续运作导致的标记变化，这个阶段的挺短时间会比初始标记长一些，但是比并发标记的时间短。
        + 并发清除
            + 执行时间较长，工作线程不停顿
            + 多线程清除已标记的对象
    + 优点: 并发收集，低停顿
    + 缺点: 产生大量空间碎片、并发阶段会降低吞吐量
6. G1收集器(此部分还需深入学习)
最新的成果之一，Hotspot开发团队赋予它的使命是未来可以替换掉JDK1.5中的CMS
+ G1 特点：
    + 空间整合，采用标记整理算法，不会产生内存空间碎片。
    + 可预测停顿，降低停顿时间是G1和CMS的共同关注点，但G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的时间模型，能让使用者明确指定一个长度为N毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。
    + G1 不再将新生代和老年代进行物理隔离，而是一视同仁的划分成等大的若干个Region
+ 收集步骤
    + 初始标记 + Minor GC (Stop The World)
    + Root Region Scanning
    + 并发标记
    + 重新标记(Stop The World)
    + 拷贝-清理(Stop The World)